package org.smartjava.scalatra.repository
// simple implementation of the bidrepository

import org.smartjava.scalatra.model.Bid


import scala.slick.session._
import scala.slick.lifted.TypeMapper._
//import scala.slick.driver.PostgresDriver._
import scala.slick.driver.MySQLDriver.simple._

class BidRepository extends RepositoryBase {

  object BidMapping extends Table[(Option[Long], Long, Double, Double, String, Long, Long)]("sc_bid") {
    def id = column[Option[Long]]("id", O PrimaryKey)
    def forItem = column[Long]("item", O NotNull)
    def min = column[Double]("min", O NotNull)
    def max = column[Double]("max", O NotNull)
    def currency = column[String]("currency")
    def bidder = column[Long]("bidder", O NotNull)
    def date = column[Long]("date", O NotNull)

    def noID = forItem ~ min ~ max ~ currency ~ bidder ~ date
    def * = id ~ forItem ~ min ~ max ~ currency ~ bidder ~ date
  }

  /**
   * Return a Option[Bid] if found or None otherwise
   */
  def get(bid: Long, user: String) : Option[Bid] = {
      var result:Option[Bid] = None;
 
      db withSession {
          // define the query and what we want as result
    	  val query = for (u <-BidMapping if u.id === bid) yield u.id ~ u.forItem ~ u.min ~ u.max ~ u.currency ~ u.bidder ~ u.date
 
    	  // map the results to a Bid object
    	  val inter = query mapResult {
    	    case(id,forItem,min,max,currency,bidder,date) => Option(new Bid(id,forItem, min, max, currency, bidder, date));
    	  }
 
//    	  // check if there is one in the list and return it, or None otherwise
//    	  result = inter.list match {
//    	    case _ :: tail => inter.first
//    	    case Nil => None
//    	  }
      }
 
      // return the found bid
      result
    }

  /**
   * Create a bid using scala query. This will always create a new bid
   */
  def create(bid: Bid) = {
    var id: Long = -1;

//    // start a db session
//    db withSession {
//      // create a new bid
//      val res = BidMapping.noID insert (bid.forItem.longValue, bid.minimum.doubleValue, bid.maximum.doubleValue, 	bid.currency, bid.bidder.toLong, System.currentTimeMillis());
//      
//      // get the autogenerated bid
//      val idQuery = Query(SimpleFunction.nullary[Long]("LASTVAL"));
//      id = idQuery.list().head;
//    }
//    // create a bid to return
//    val createdBid = new Bid(Option(id), bid.forItem, bid.minimum, bid.maximum, bid.currency, bid.bidder, bid.date);
//    createdBid;
  }

  /**
   * Delete a bid
   */
  def delete(user: String, bid: Long) = {
    // get the bid we're deleting
    val result = get(bid, user);

    // delete the bid
    val toDelete = BidMapping where (_.id === bid)
    db withSession {
//      toDelete.delete
    }

    // return deleted bid
    result
  }
}